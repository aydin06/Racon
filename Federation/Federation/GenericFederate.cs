// ***************************************************************************
//                          RACoN.Federate
//		begin                : Jul 17, 2009
// ***************************************************************************

/* 
RACoN - RTI abstraction component for MS.NET (RACoN)
https://sites.google.com/site/okantopcu/racon

Copyright © Okan Topçu, 2009-2016
otot.support@outlook.com

This program is free software : you can redistribute it and / or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program.If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Windows.Forms;//MessageBox
using System.ComponentModel;//BackgroundWorker
using System.Diagnostics.Contracts;
using System.Linq;//.ToList()
using Racon.ObjectModel;
// RACoN
using Racon.RtiLayer;
using Racon.RtiLayer.Native;
using Racon.Logger;

namespace Racon.Federation
{
  /// <summary>
  /// Presents an extension point for application-specific federates. The generic federate defines the abstraction and is implemented as a wrapper façade class. 
  /// </summary>
  /// <remarks>
  /// <para> This class is the base wrapper for the RTI-specific classes (i.e. the RTI Layer) and the main extension point. This class should be inherited by a class that encapsulates the federate-specific data.</para>
  /// <para> Most federate developers (mainly students or inexperienced simulation developers) are not interested in the details of this subsystem, which complicate their implementation; instead their only need is to initialize the federation ex-ecution. Hence, the generic federate provides a higher-level interface. The developer calls only the method (InitializeFederation) rather than calling related series of low-level RTI methods (such as; create federation, join federation, create regions, and publish and subscribe classes). One of the rationales here is to simplify the interface for novice HLA users by hiding the perplexing RTI class relationships. On the other hand, the low-level RTI methods can still be called using the CRtiAmb.</para>
  /// <para>RACoN provides notifications about HLA-related services to the application-specific federate by using events (event-based notification). Therefore, an application-specific federate can handle events triggered from the commu-nication layer by overriding the event handlers that are subscribed by the base federate in order to customize their RTI-related behaviors (delegated event handling). For example, when a new object is discovered, the RACoN assembly raises a new object discovered event. The application-specific fed-erate that hooks the event, is notified that the event has been triggered. Then, the application-specific federate can take action such as adding the new ob-ject to its scene graph or creating a local substitute for that object. .NET event handling structures are used for implementing events and event handling mechanisms. Events are categorized according to their initiators, as follows: </para>
  /// <list type="bullet">
  /// <item>RTI-initiated events generated by federate ambassador callbacks such as an object discovered event. </item>
  /// <item>Federate-initiated events generated by the RTI ambassador such as a federate joined event. </item>
  /// <item>RACoN events generated by the generic federate such as a feder-ate state changed event.</item>
  /// </list>
  /// <para>The federate-initiated and RACON event handlers are executed as soon as they are raised, but, the RTI-initiated events (callbacks from the RTI to the federate ambassador) are queued as events for processing at the end of each simulation cycle. They are executed when the federate run method is called. The federate Run() method must be called in the main (simulation loop) of the application.</para>
  /// </remarks>
  public abstract class CGenericFederate : CallbackManager
  {
    #region Fields
    private CRtiAmb _rtiAmb; // Generic RTI Ambassador
    private RTILibraryType _RtiLibrary; // Current RTI Library reference
    private CObjectModel _som;
    private FederateStates _FederateState;
    private FederationExecutionStates _FederationExecutionState;
    // Loggers
    private string _statusMessage;
    private LogManager logger;
    //private StringBuilder _TraceLog;
    //private LogLevel _LogLevel;
    #endregion // Fields

    #region Properties
    /// <summary>
    /// The reference for internal RTI ambassador. This reference can be used to access internal RTI ambassador interface
    /// </summary>
    protected CRtiAmb RtiAmb
    {
      get { return _rtiAmb; }
    }

    /// <summary>
    /// Current federate state. When it is set, it raises <see cref="Racon.Federation.CGenericFederate.FederateStateChanged"/> Event.
    /// </summary>
    public FederateStates FederateState
    {
      get { return _FederateState; }
      set
      {
        _FederateState = value;
        OnFederateStateChanged(new CFederateStateEventArgs(_FederateState));
        //StatusMessage = "Federate State: " + _FederateState.ToString();
        logger.Add("Federate State: " + _FederateState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// Current federation execution state. When it is set, it raises <see cref="Racon.Federation.CGenericFederate.FederationStateChanged"/> Event.
    /// </summary>
    public FederationExecutionStates FederationExecutionState
    {
      get { return _FederationExecutionState; }
      private set // Only RACoN assemblies can set 
      {
        _FederationExecutionState = value;
        OnFederationStateChanged(new CFederationStateEventArgs(_FederationExecutionState));
        logger.Add("Federation State: " + _FederationExecutionState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// The log message RACoN. When it is set, it raises <see cref="Racon.Federation.CGenericFederate.StatusMessageChanged"/> Event.
    /// </summary>
    public string StatusMessage
    {
      get { return _statusMessage; }
      private set
      {
        _statusMessage = value;
        // Raise the status changed event
        if (LogLevel != LogLevel.OFF)
        {
          OnStatusMessageChanged();
        }
      }
    }
    
    /// <summary>
    /// TraceLog dumbs the logger.Log
    /// </summary>
    public string TraceLog
    {
      get
      {
        return logger.ToString();
      }
    }

    /// <summary>
    /// Current Log Level. When it is set, it reports version, RTI native library, and current log level via <see cref="Racon.Federation.CGenericFederate.StatusMessage"/>. 
    /// </summary>
    public LogLevel LogLevel
    {
      get { return logger.LogLevel; }
      set
      {
        logger.LogLevel = value;
        // report initialization state
        logger.Add("RACoN RTI library used: " + RTILibrary.ToString(), LogLevel.INFO);
        logger.Add("Native RTI library: " + _rtiAmb.RtiVersion, LogLevel.INFO);
        logger.Add("Federate State: " + FederateState.ToString(), LogLevel.INFO);
        logger.Add("Federation State: " + _FederationExecutionState.ToString(), LogLevel.INFO);
      }
    }

    /// <summary>
    /// Current type of native RTI Library. It is set via constructor only, <see cref="Racon.Federation.CGenericFederate.RtiAmb"/> switches accordingly.
    /// </summary>
    public RTILibraryType RTILibrary
    {
      get { return _RtiLibrary; }
      private set
      {
        _RtiLibrary = value;
        switch (_RtiLibrary)
        {
          case RTILibraryType.HLA13_DMSO:
            _rtiAmb = new RtiAmb_Dmso_Hla13(this);
            break;
          case RTILibraryType.HLA13_Portico:
            _rtiAmb = new RtiAmb_Portico_Hla13(this);
            break;
          case RTILibraryType.HLA13_OpenRti:
            _rtiAmb = new RtiAmb_OpenRti_Hla13(this);
            break;
          case RTILibraryType.HLA1516e_Portico:
            _rtiAmb = new RtiAmb_OpenRti_1516e(this);
            break;
          case RTILibraryType.HLA1516e_OpenRti:
            _rtiAmb = new RtiAmb_OpenRti_1516e(this);
            break;
          default:
            break;
        }
      }
    }

    /// <summary>
    /// The federation execution that this federate will interact (e.g. create, join etc.).
    /// </summary>
    public CFederationExecution FederationExecution { get; set; }

    /// <summary>
    /// Federate handle.
    /// </summary>
    public ulong FederateHandle { get; set; }

    #endregion // Properties

    #region Delegates
    //public delegate void FederateStateChangedHandler(object sender, CFederateStateEventArgs fe);
    #endregion // Delegates (function pointers)

    #region Events
    /// <summary>
    /// Log message change event.
    /// </summary>
    public event EventHandler StatusMessageChanged;
    /// <summary>
    /// Federate state change event.
    /// </summary>
    public event EventHandler<CFederateStateEventArgs> FederateStateChanged;
    /// <summary>
    /// Federation state change event.
    /// </summary>
    public event EventHandler<CFederationStateEventArgs> FederationStateChanged;
    #endregion // Events

    #region EventRaisers
    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnStatusMessageChanged()
    {
      StatusMessageChanged?.Invoke(this, EventArgs.Empty);// Raise the event.
    }

    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnFederateStateChanged(CFederateStateEventArgs e)
    {
      FederateStateChanged?.Invoke(this, e);// Raise the event.
    }

    /// <summary>
    /// Wraps the event in a protected virtual method to enable derived classes to raise the event.
    /// </summary>
    protected virtual void OnFederationStateChanged(CFederationStateEventArgs e)
    {
      FederationStateChanged?.Invoke(this, e);// Raise the event.
    }

    #endregion // Event Raisers

    #region Constructors
    /// <summary>
    /// CGenericFederate constructor
    /// </summary>
    /// <param name="rti"> Native RTI library reference. Default is RTILibraryType.HLA1516e_OpenRti</param>
    public CGenericFederate(RTILibraryType rti = RTILibraryType.HLA1516e_OpenRti)
      : base()
    {
      // Set Default RTI
      RTILibrary = rti;
      // Instantiate members
      _som = new CObjectModel();
      FederationExecution = new CFederationExecution();
      // initialize logger
      logger = new LogManager();
      logger.Log.CollectionChanged += Log_ListChanged;
      // Set states
      _FederationExecutionState = FederationExecutionStates.FEDEX_DOESNOTEXIST;
      _FederateState = FederateStates.NOTCONNECTED;
      // Subscribe to the Contract Failed Event for Pre- and post conditions
      Contract.ContractFailed += Contract_ContractFailed;
      // Subscribe to the HLA-specific service events (RACoN Events + RTI Events + Federate Events)
      _rtiAmb.NoConnection += RtiAmb_NotConnected;
      _rtiAmb.FederateConnected += RtiAmb_FederateConnected;
      _rtiAmb.FederateDisconnected += RtiAmb_FederateDisconnected; ;
      _rtiAmb.FederateJoined += RtiAmb_FederateJoined;
      _rtiAmb.FederateResigned += RtiAmb_FederateResigned;
      _rtiAmb.FederationExecutionCreated += RtiAmb_FederationExecutionCreated;
      _rtiAmb.FederationExecutionDestroyed += RtiAmb_FederationExecutionDestroyed;
      _rtiAmb.ObjectRegistered += RtiAmb_ObjectRegistered;
      _rtiAmb.HLAClassPublished += RtiAmb_HLAClassPublished;
      _rtiAmb.HLAClassSubscribed += RtiAmb_HLAClassSubscribed;
      _rtiAmb.RTIEventOccured += RtiAmb_RTIEventOccured;
      // FM
      ConnectionLost += FdAmb_ConnectionLost;
      FederationExecutionsReported += FdAmb_FederationExecutionsReported;
      SynchronizationPointRegistrationSucceeded += FdAmb_OnSynchronizationPointRegistrationConfirmedHandler;
      SynchronizationPointRegistrationFailed += FdAmb_OnSynchronizationPointRegistrationFailedHandler;
      SynchronizationPointAnnounced += FdAmb_SynchronizationPointAnnounced;
      FederationSynchronized += FdAmb_FederationSynchronized;
      InitiateFederateSave += FdAmb_InitiateFederateSaveHandler;
      InitiateFederateRestore += FdAmb_InitiateFederateRestoreHandler;
      FederationRestorationRequestConfirmed += FdAmb_ConfirmFederationRestorationRequestHandler;
      FederationRestored += FdAmb_FederationRestored;
      FederationSaved += FdAmb_FederationSaved;
      FederationRestoreBegun += FdAmb_FederationRestoreBegun;
      // DM
      StartRegistrationForObjectClassAdvised += FdAmb_StartRegistrationForObjectClassAdvisedHandler;
      StopRegistrationForObjectClassAdvised += FdAmb_StopRegistrationForObjectClassAdvisedHandler;
      TurnInteractionsOffAdvised += FdAmb_TurnInteractionsOffAdvisedHandler;
      TurnInteractionsOnAdvised += FdAmb_TurnInteractionsOnAdvisedHandler;
      // OM
      ObjectDiscovered += FdAmb_ObjectDiscoveredHandler;
      ObjectRemoved += FdAmb_ObjectRemovedHandler;
      ObjectAttributesReflected += FdAmb_ObjectAttributesReflectedHandler;
      InteractionReceived += FdAmb_InteractionReceivedHandler;
      AttributeValueUpdateRequested += FdAmb_AttributeValueUpdateRequestedHandler;
      // OwM
      AttributeOwnershipReleaseRequested += FdAmb_AttributeOwnershipReleaseRequestedHandler;
      AttributeOwnershipInformed += FdAmb_AttributeOwnershipInformed;
      AttributeOwnershipAcquisitionNotified += FdAmb_AttributeOwnershipAcquisitionNotified;
      AttributeOwnershipDivestitureNotified += FdAmb_AttributeOwnershipDivestitureNotified;
      AttributeOwnershipUnavailable += FdAmb_AttributeOwnershipUnavailable;
      AttributeOwnershipAcquisitionCancellationConfirmed += FdAmb_AttributeOwnershipAcquisitionCancellationConfirmed;
      AttributeOwnershipAssumptionRequested += FdAmb_AttributeOwnershipAssumptionRequested;
      // TM
      TimeConstrainedEnabled += FdAmb_TimeConstrainedEnabled;
      TimeRegulationEnabled += FdAmb_TimeRegulationEnabled;
      TimeAdvanceGrant += FdAmb_TimeAdvanceGrant;
      RequestRetraction += FdAmb_RequestRetraction;

      // Start the federate clock
      //FederateClock.StartClock();
      //backgroundWorker1.DoWork += new DoWorkEventHandler(FdAmb_ObjectAttributesReflected);
      //backgroundWorker1.RunWorkerCompleted += new RunWorkerCompletedEventHandler(FdAmb_ObjectAttributesReflected);
    }
    #endregion // Constructors

    #region Event Handlers

    #region RTI-initiated Callback Event Handlers
    #region FM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ConnectionLost(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
      // In case of RTI crash - resign and disconnect
      bool res = ResignFederationExecution();
      if (res) Disconnect();
    }
    /// <summary>
    /// Federate ambassador callback for Federation Executions Reported
    /// </summary>
    public virtual void FdAmb_FederationExecutionsReported(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// FdAmb_OnSynchronizationPointRegistrationConfirmedHandler
    /// </summary>
    public virtual void FdAmb_OnSynchronizationPointRegistrationConfirmedHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// FdAmb_OnSynchronizationPointRegistrationFailedHandler
    /// </summary>
    public virtual void FdAmb_OnSynchronizationPointRegistrationFailedHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback. FdAmb_SynchronizationPointAnnounced.
    /// </summary>
    public virtual void FdAmb_SynchronizationPointAnnounced(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback. FdAmb_FederationSynchronized
    /// </summary>
    public virtual void FdAmb_FederationSynchronized(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InitiateFederateSaveHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InitiateFederateRestoreHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ConfirmFederationRestorationRequestHandler(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationSaved(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationRestored(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_FederationRestoreBegun(object sender, HlaFederationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    #endregion // FM Handlers
    #region DM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_StartRegistrationForObjectClassAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_StopRegistrationForObjectClassAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TurnInteractionsOffAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TurnInteractionsOnAdvisedHandler(object sender, HlaDeclarationManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    #endregion // DM Handlers
    #region OM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectDiscoveredHandler(object sender, HlaObjectEventArgs data)
    {
      //// Multiple parameter passing - Example
      //ThreadStart starter = delegate { FdAmb_ObjectDiscovered(sender, data); };
      //new Thread(starter).Start();

      //// Only one parameter passing
      //Thread thread = new Thread(new ParameterizedThreadStart(FdAmb_ObjectDiscovered));
      //thread.Start(data);

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectRemovedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeValueUpdateRequestedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_InteractionReceivedHandler(object sender, HlaInteractionEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_ObjectAttributesReflectedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback - TurnUpdatesOnForObjectInstance
    /// </summary>
    public virtual void FdAmb_TurnUpdatesOnForObjectInstanceAdvisedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback - TurnUpdatesOffForObjectInstance
    /// </summary>
    public virtual void FdAmb_TurnUpdatesOffForObjectInstanceAdvisedHandler(object sender, HlaObjectEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    #endregion // OM Handlers
    #region OwM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAssumptionRequested(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAcquisitionCancellationConfirmed(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipUnavailable(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback // HLA13 only
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipDivestitureNotified(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipAcquisitionNotified(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipInformed(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// Federate ambassador callback // HLA13 only
    /// </summary>
    public virtual void FdAmb_AttributeOwnershipReleaseRequestedHandler(object sender, HlaOwnershipManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    #endregion // OwM Handlers
    #region TM handlers
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeConstrainedEnabled(object sender, HlaTimeManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeRegulationEnabled(object sender, HlaTimeManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_TimeAdvanceGrant(object sender, HlaTimeManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    /// <summary>
    /// Federate ambassador callback
    /// </summary>
    public virtual void FdAmb_RequestRetraction(object sender, HlaTimeManagementEventArgs data)
    {

      logger.Add(data.TraceMessage);
    }
    #endregion // TM Handlers
    #endregion // RTI-initiated Callback Event Handlers

    #region RtiAmb Handlers

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateConnected
    /// </summary>
    private void RtiAmb_NotConnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederateState = FederateStates.NOTCONNECTED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateConnected
    /// </summary>
    private void RtiAmb_FederateConnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederateState = FederateStates.CONNECTED | FederateStates.NOTJOINED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateDisconnected
    /// </summary>
    private void RtiAmb_FederateDisconnected(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederateState = FederateStates.NOTCONNECTED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateJoined
    /// </summary>
    public virtual void RtiAmb_FederateJoined(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederateState = FederateStates.CONNECTED | FederateStates.JOINED | FederateStates.FREERUN;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederateResigned
    /// </summary>
    public virtual void RtiAmb_FederateResigned(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederateState = FederateStates.CONNECTED | FederateStates.NOTJOINED;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederationExecutionCreated
    /// </summary>
    public virtual void RtiAmb_FederationExecutionCreated(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederationExecutionState = FederationExecutionStates.FEDEX_EXISTS;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_FederationExecutionDestroyed
    /// </summary>
    public virtual void RtiAmb_FederationExecutionDestroyed(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
      FederationExecutionState = FederationExecutionStates.FEDEX_DOESNOTEXIST;
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_ObjectRegistered
    /// </summary>
    public virtual void RtiAmb_ObjectRegistered(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_HLAClassPublished
    /// </summary>
    public virtual void RtiAmb_HLAClassPublished(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_HLAClassSubscribed
    /// </summary>
    public virtual void RtiAmb_HLAClassSubscribed(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }

    /// <summary>
    /// RTI ambassador handler for RtiAmb_RTIEventOccured
    /// </summary>
    public virtual void RtiAmb_RTIEventOccured(object sender, RaconEventArgs data)
    {
      logger.Add(data.TraceMessage);
    }
    #endregion // RTIAmb Handlers

    #region Contract Handlers
    /// <summary>
    ///Contract handler
    /// </summary>
    private void Contract_ContractFailed(object sender, ContractFailedEventArgs data)
    {
      logger.Add("Contract Failed: " + data.Message, LogLevel.WARN);
      data.SetHandled();
    }
    #endregion // Contract Handlers

    #region Logger Handlers
    /// <summary>
    /// Whenever a new log entry happens, this is used to check to report the message according to log level
    /// </summary>
    private void Log_ListChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
      // CREATE
      if (e.NewItems != null && e.NewItems.Count != 0)
        foreach (LogEntry node in e.NewItems)
        {
          // Report message according to Log Level
          if (node.Level >= logger.LogLevel)
            StatusMessage = node.Message;
        }
    }
    #endregion

    #endregion // Event Handlers

    #region Methods
    /// <summary>
    /// Method to tick and process the callbacks.
    /// </summary>
    /// <remarks>This method is called to tick and process the callbacks. Typically, it is called in main simuation loop.
    /// </remarks>
    virtual public void Run()
    {
      EvokeCallback();
      #region Process the FdAmb Event Queues
      while (FdAmbEventQueue.Count != 0)
      {
        //StatusMessage = "Queue Count = " + FdAmbEventQueue.Count;
        RaconEventArgs AnEventInstance = FdAmbEventQueue.Dequeue();
        //StatusMessage = "Event Type = " + AnEventInstance.EventType;
        switch (AnEventInstance.EventType)
        {
          // FM
          case RaconEventTypes.ConnectionLost:
            OnConnectionLost((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationExecutionsReported:
            OnFederationExecutionsReported((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.SynchronizationPointRegistrationSucceeded:
            OnSynchronizationPointRegistrationConfirmed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.synchronizationPointRegistrationFailed:
            OnSynchronizationPointRegistrationFailed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.SynchronizationPointAnnounced:
            OnSynchronizationPointAnnounced((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationSynchronized:
            OnFederationSynchronized((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.InitiateFederateSave:
            OnInitiateFederateSave((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.InitiateFederateRestore:
            OnInitiateFederateRestore((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestorationRequestConfirmed:
            OnFederationRestorationRequestConfirmed((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationSaved:
            OnFederationSaved((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestored:
            OnFederationRestored((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.FederationRestoreBegun:
            OnFederationRestoreBegun((HlaFederationManagementEventArgs)AnEventInstance);
            break;
          // DM
          case RaconEventTypes.StartRegistrationForObjectClassAdvised:
            OnStartRegistrationForObjectClassAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.StopRegistrationForObjectClassAdvised:
            OnStopRegistrationForObjectClassAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnInteractionsOffAdvised:
            OnTurnInteractionsOffAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnInteractionsOnAdvised:
            OnTurnInteractionsOnAdvised((HlaDeclarationManagementEventArgs)AnEventInstance);
            break;
          // OM
          case RaconEventTypes.ObjectDiscovered:
            OnObjectDiscovered((HlaObjectEventArgs)AnEventInstance);
            //StatusMessage = "here-1";
            break;
          case RaconEventTypes.ObjectRemoved:
            OnObjectRemoved((HlaObjectEventArgs)AnEventInstance);
            //StatusMessage = "here-2";
            break;
          case RaconEventTypes.InteractionReceived:
            HlaInteractionEventArgs interactionArgs = (HlaInteractionEventArgs)AnEventInstance;
            OnInteractionReceived(interactionArgs);
            foreach (var obj in interactionArgs.Interaction.Parameters)
            {
              obj.FreeIntPtrMemory();
              //FreeIntPtrMemory(obj.Value);
            }
            break;
          case RaconEventTypes.AttributeValueUpdateRequested:
            OnAttributeValueUpdateRequested((HlaObjectEventArgs)AnEventInstance);
            //StatusMessage = "here-4";
            break;
          case RaconEventTypes.ObjectAttributesReflected:
            HlaObjectEventArgs objectArgs = (HlaObjectEventArgs)AnEventInstance;
            OnObjectAttributesReflected(objectArgs);
            foreach (var obj in objectArgs.ObjectInstance.Attributes)
            {
              obj.FreeIntPtrMemory();
              //FreeIntPtrMemory(obj.Value);
            }
            break;
          case RaconEventTypes.TurnUpdatesOnForObjectInstanceAdvised:
            OnTurnUpdatesOnForObjectInstanceAdvised((HlaObjectEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TurnUpdatesOffForObjectInstanceAdvised:
            OnTurnUpdatesOffForObjectInstanceAdvised((HlaObjectEventArgs)AnEventInstance);
            break;

          // OwM
          case RaconEventTypes.AttributeOwnershipAssumptionRequested:
            OnAttributeOwnershipAssumptionRequested((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipAcquisitionCancellationConfirmed:
            OnAttributeOwnershipAcquisitionCancellationConfirmed((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipUnavailable:
            OnAttributeOwnershipUnavailable((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipAcquisitionNotified:
            OnAttributeOwnershipAcquisitionNotified((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipDivestitureNotified:
            OnAttributeOwnershipDivestitureNotified((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipReleaseRequested:
            OnAttributeOwnershipReleaseRequested((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.AttributeOwnershipInformed:
            OnAttributeOwnershipInformed((HlaOwnershipManagementEventArgs)AnEventInstance);
            break;
          // TM
          case RaconEventTypes.TimeConstrainedEnabled:
            OnTimeConstrainedEnabled((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TimeRegulationEnabled:
            OnTimeRegulationEnabled((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.TimeAdvanceGrant:
            OnTimeAdvanceGrant((HlaTimeManagementEventArgs)AnEventInstance);
            break;
          case RaconEventTypes.RequestRetraction:
            OnRequestRetraction((HlaTimeManagementEventArgs)AnEventInstance);
            break;
        }
      }
      #endregion
    }

    /// <summary>
    /// Sets the simulation object model for federate.
    /// </summary>
    /// <param name="objectModel">Object Model</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SetSom(CObjectModel objectModel)
    {
      _som = objectModel;
      _som.RtiAmb = _rtiAmb;
      //// Object Classes
      //foreach (HlaObjectClass oc in objectModel.OCList)
      //  _som.AddToObjectModel(oc);
      //// Interaction Classes
      //foreach (HlaInteractionClass ic in objectModel.ICList)
      //  _som.AddToObjectModel(ic);
      //// Routing Spaces
      //foreach (CRoutingSpace rs in objectModel.RSList)
      //  _som.AddToObjectModel(rs);

      //_som.RtiAmb = objectModel.RtiAmb;

      return true;
    }

    #region RtiAmb Function Wrappers

    #region Federation Management

    /// <summary>
    /// Initializes federation execution
    /// </summary>
    /// <param name="fedexec">Federation Execution</param>
    /// <returns>returns True/False.</returns>
    /// <remarks>High level interface. This method creates federation if it is first one, joins federation, creates regions, and publishes and subscribes classes.
    /// </remarks>
    virtual public bool InitializeFederation(CFederationExecution fedexec)
    {
      // fedexec'e gerek var mı? to support multiple federation executions

      #region Contracts
      // Preconditions
      Contract.Requires(fedexec != null, "CFederationExecution instance passed to FinalizeFederation() method is null.");
      Contract.Requires(fedexec.Name != null, "Federation Execution Name passed to InitializeFederation() method is null.");
      Contract.Requires(fedexec.FDD != null, "FDD passed to InitializeFederation() method is null.");
      Contract.Requires(FederationExecution.FederateName != null, "Federate Name passed to InitializeFederation() method is null.");
      // Postconditions
      Contract.Ensures(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at InitializeFederation().");
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at InitializeFederation().");
      #endregion

      bool res = Connect(fedexec.ConnectionSettings);

      if (res)
        res = CreateFederationExecution(fedexec.Name, fedexec.FDD);
      //Contract.Assert(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, "After createFederation() call, federation state is not set to CREATED in InitializeFederation() method.");// Runs only in debug mode
      if (res)
        res = JoinFederationExecution(fedexec.Name, fedexec.FederateName);

      if (res)
      {
        // Data Distribution Management
        createRegions();
        // Declare publish and subscribe interests.
        declareCapability();
      }

      return res;
    }

    /// <summary>
    /// Connects to RTI
    /// </summary>
    /// <param name="localSettingsDesignator">Connection paramaters in form of "protocol"://"ip":"port". For example: rti://127.0.0.1:12345 </param>
    /// <returns>returns True/False.</returns>    
    /// <remarks>This method is for IEEE1516-2010 compatiblity. Sets the federate status as CONNECTED.
    /// </remarks>
    virtual public bool Connect(string localSettingsDesignator = "")
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState == FederateStates.NOTCONNECTED, " at Connect().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.CONNECTED), "After Connect() call, federate state is not set correctly at Connect().");
      #endregion

      if (FederateState.HasFlag(FederateStates.NOTCONNECTED))
        _rtiAmb.connect(localSettingsDesignator);
      return FederateState.HasFlag(FederateStates.CONNECTED) ? true : false;
    }

    /// <summary>
    /// Disconnects from RTI
    /// </summary>
    /// <remarks>This method is for IEEE1516-2010 compatiblity. Sets the federate status as NOTCONNECTED.
    /// </remarks>
    virtual public bool Disconnect()
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED | FederateStates.NOTJOINED), " at Disconnect().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.NOTCONNECTED), "After Disconnect() call, federate state is not set correctly at Disconnect().");
      #endregion

      if (FederateState.HasFlag(FederateStates.CONNECTED))
        _rtiAmb.disconnect();
      return FederateState.HasFlag(FederateStates.NOTCONNECTED) ? true : false;
    }

    /// <summary>
    /// Creates a federation execution 
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution to be destroyed.</param>
    /// <param name="fdd">Path of the FDD file.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method creates federation execution.
    /// </remarks>
    virtual public bool CreateFederationExecution(string fedexName, string fdd)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at CreateFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at CreateFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at CreateFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST))
        _rtiAmb.createFederation(fedexName, fdd);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS) ? true : false;
    }

    /// <summary>
    /// (IEEE1516.1-2010 4.7) Requests a list of current federation executions
    /// </summary>
    virtual public void ListFederationExecutions()
    {
      if (FederateState.HasFlag(FederateStates.CONNECTED))
        _rtiAmb.listFederationExecutions();
    }

    /// <summary>
    /// Joins a federation execution 
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution to be destroyed.</param>
    /// <param name="federateName">Name of the joined federate.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>Federate joins a federation execution.
    /// </remarks>
    virtual public bool JoinFederationExecution(string fedexName, string federateName)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at JoinFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at JoinFederationExecution().");
      Contract.Requires(FederateState.HasFlag(FederateStates.NOTJOINED), " at JoinFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.JOINED), " at JoinFederationExecution().");
      #endregion

      if (FederateState.HasFlag(FederateStates.NOTJOINED))
        FederateHandle = _rtiAmb.joinFederation(fedexName, federateName);
      return FederateState.HasFlag(FederateStates.JOINED) ? true : false;
    }

    /// <summary>
    /// Finalizes federation execution with user selected Resign Action:
    /// (1) Resign federation execution
    /// (2) Try to destroy federation execution
    /// (3) Disconnect
    /// </summary>
    /// <param name="fedexec">Federation Execution</param>
    /// <param name="action">Resign Action. Default is ResignAction.DELETE_OBJECTS_THEN_DIVEST</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>Higher level interface. This method resigns federation, destroys federation if it is last one.
    /// </remarks>
    virtual public bool FinalizeFederation(CFederationExecution fedexec, ResignAction action = ResignAction.DELETE_OBJECTS_THEN_DIVEST)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(fedexec != null, "CFederationExecution instance passed to FinalizeFederation() method is null.");
      Contract.Requires(fedexec.Name != null, "Federation Execution Name passed to FinalizeFederation() method is null.");
      #endregion

      bool res = ResignFederationExecution(action);
      if (res)
        DestroyFederationExecution(fedexec.Name);
      res = Disconnect();
      return res;

      // Log the Error into the eventlog (application)
      // !!! Needs admin rights
      //EventLog::WriteEntry("ExPFd","Exception Type: "+e->GetType()->FullName+"\r\nError Message: "+e->Message+"\r\nStack: "+e->StackTrace+""+Environment.NewLine,EventLogEntryType::Warning);
    }

    /// <summary>
    /// Resigns federation execution with user selected Resign Action 
    /// </summary>
    /// <param name="action">Resign Action</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method resigns federation execution.
    /// </remarks>
    virtual public bool ResignFederationExecution(ResignAction action = ResignAction.NO_ACTION)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at ResignFederationExecution().");
      // Postconditions
      Contract.Ensures(FederateState.HasFlag(FederateStates.NOTJOINED), " at FinalizeFederation().");
      #endregion

      if (FederateState.HasFlag(FederateStates.JOINED))
        _rtiAmb.resignFederation((int)action);
      return FederateState.HasFlag(FederateStates.NOTJOINED) ? true : false;
    }

    /// <summary>
    /// Destroys the federation execution specified with a name
    /// </summary>
    /// <param name="fedexName">Name of the Federation Execution to be destroyed.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method destroys federation execution.
    /// </remarks>
    virtual public bool DestroyFederationExecution(string fedexName)
    {
      #region Contracts
      // Preconditions
      Contract.Requires(FederateState.HasFlag(FederateStates.CONNECTED), " at DestroyFederationExecution().");
      Contract.Requires(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS), " at DestroyFederationExecution().");
      // Postconditions
      Contract.Ensures(FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST), " at DestroyFederationExecution().");
      #endregion

      if (FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_EXISTS))
        _rtiAmb.destroyFederation(fedexName);
      return FederationExecutionState.HasFlag(FederationExecutionStates.FEDEX_DOESNOTEXIST) ? true : false;
    }

    /// <summary>
    /// This method shall be used to initiate the registration of an upcoming federation synchronization point label.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="tag">User-supplied tag</param>
    virtual public void RegisterFederationSynchronizationPoint(string label, string tag = "")
    {
      _rtiAmb.registerFederationSynchronizationPoint(label, tag);
    }

    /// <summary>
    /// This method shall be used to initiate the registration of an upcoming federation synchronization point label.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="tag">User-supplied tag</param>
    /// <param name="federates">set of joined federate designators</param>
    virtual public void RegisterFederationSynchronizationPoint(string label, string tag, List<uint> federates)
    {
      _rtiAmb.registerFederationSynchronizationPoint(label, tag, federates);
    }

    /// <summary>
    /// This method shall inform the RTI that the joined federate has reached the specified synchronization point.
    /// </summary>
    /// <param name="label">Synchronization point label</param>
    /// <param name="result">Optional synchronization-success indicator</param>
    virtual public void SynchronizationPointAchieved(string label, bool result = true)
    {
      _rtiAmb.synchronizationPointAchieved(label, result);
    }

    /// <summary>
    /// This method requests a federation save as soon as possible supplied with a string associated to a particular save.
    /// </summary>
    /// <param name="label">String label</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationSave(string label)
    {
      _rtiAmb.requestFederationSave(label);
    }

    /// <summary>
    /// This method requests a federation save at the specified time supplied with a string associated to a particular save.
    /// </summary>
    /// <param name="label">String label</param>
    /// <param name="time">time</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationSave(string label, double time)
    {
      _rtiAmb.requestFederationSave(label, time);
    }

    /// <summary>
    /// This method informs RTI that save begun.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateSaveBegun()
    {
      _rtiAmb.federateSaveBegun();
    }

    /// <summary>
    /// A false value indicates the unsuccessful completion of a save of a federate-managed state, as initiated by an initiateFederateSave() callback. A true value indicates a successful completion.
    /// </summary>
    /// <param name="isCompleted">isCompleted</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateSaveComplete(bool isCompleted)
    {
      // can we make this a property?
      _rtiAmb.federateSaveComplete(isCompleted);
    }

    /// <summary>
    /// This method requests a federation restore associated with a previously saved name federation state.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void RequestFederationRestore(string label)
    {
      _rtiAmb.requestFederationRestore(label);
    }

    /// <summary>
    /// A false value indicates the unsuccessful completion of a restoration of a federate-managed state. A true value indicates a successful completion.
    /// </summary>
    /// <param name="isCompleted">isCompleted</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public void FederateRestoreComplete(bool isCompleted)
    {
      // can we make this a property?
      _rtiAmb.federateRestoreComplete(isCompleted);
    }

    #endregion // Federation Management

    #region Declaration Management
    /// <summary>
    /// Declares capability of a federate in terms of Publish/Subscribe:
    /// (1) Enables object class relevance advisory switch.
    /// (2) Gets object class and attribute handles.
    /// (3) Publishs/subscribes all the object classes in SOM according to their PS status.
    /// (4) Enables interaction relevance advisory switch.
    /// (5) Gets interaction class and parameter handles.
    /// (6) Publishs/subscribes all the interaction classes in SOM according to their PS status.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual internal bool declareCapability()
    {
      try
      {
        // Enable advisory switches
        EnableObjectClassRelevanceAdvisorySwitch();
        EnableInteractionRelevanceAdvisorySwitch();
        EnableAttributeRelevanceAdvisorySwitch();

        // Publish and Subscribe the OC using Federate's OC List
        foreach (var oc in _som.OCList)
        {
          // Get Class Handle
          _rtiAmb.getClassHandleFromRti(oc);
          // Get All Attribute Handles
          _rtiAmb.getAttributeHandlesFromRti(oc);
          // Publish and/or Subscribe
          switch (oc.ClassPS)
          {
            case PSKind.Publish:
              PublishObjectClass(oc);
              break;
            case PSKind.Subscribe:
              SubscribeObjectClass(oc);
              break;
            case PSKind.PublishSubscribe:
              PublishObjectClass(oc);
              SubscribeObjectClass(oc);
              break;
          };
        }
        // Publish and Subscribe the IC using Federate's IC List
        foreach (var ic in _som.ICList)
        {
          // Get Class Handle
          _rtiAmb.getClassHandleFromRti(ic);
          // Get All Attribute Handles
          _rtiAmb.getParameterHandlesFromRti(ic);
          // Publish and/or Subscribe
          switch (ic.ClassPS)
          {
            case PSKind.Publish:
              _rtiAmb.publishInteractionClass(ic);
              break;
            case PSKind.Subscribe:
              _rtiAmb.subscribeInteractionClass(ic);
              break;
            case PSKind.PublishSubscribe:
              _rtiAmb.publishInteractionClass(ic);
              _rtiAmb.subscribeInteractionClass(ic);
              break;
          };
        }
        return true;
      }
      catch (Exception)
      {
        return false;
      }
    }

    /// <summary>
    /// Publish OC - With its all subscribable attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool PublishObjectClass(HlaObjectClass oc)
    {
      return PublishObjectClass(oc, oc.Attributes);
    }

    /// <summary>
    /// Publish OC - With some selected attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <param name="attributes">Attributes</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool PublishObjectClass(HlaObjectClass oc, BindingList<HlaAttribute> attributes)
    {
      _rtiAmb.publishObjectClass(oc, attributes);
      return true;
    }

    /// <summary>
    /// Subscribes OC - With its all subscribable attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeObjectClass(HlaObjectClass oc)
    {
      return SubscribeObjectClass(oc, oc.Attributes);
    }

    /// <summary>
    /// Subscribe OC - With some selected attributes 
    /// </summary>
    /// <param name="oc">Object class</param>
    /// <param name="attributes">Attributes</param>
    /// <param name="active">default is true</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeObjectClass(HlaObjectClass oc, BindingList<HlaAttribute> attributes, bool active = true)
    {
      return _rtiAmb.subscribeObjectClass(oc, attributes, active);
    }

    /// <summary>
    /// UnsubscribeInteractionClass 
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeInteractionClass(HlaInteractionClass ic)
    {
      return _rtiAmb.unsubscribeInteractionClass(ic);
    }

    /// <summary>
    /// UnsubscribeObjectClass - For all attributes of an object class
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeObjectClass(HlaObjectClass oc)
    {
      return _rtiAmb.unsubscribeObjectClass(oc);
    }

    #endregion // Declaration Management

    #region Data Distribution Management

    /// <summary>
    /// AssociateRegionForUpdates
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool AssociateRegionForUpdates(CHlaRegion region, HlaObject hlaObject, List<HlaAttribute> attributes)
    {
      return _rtiAmb.associateRegionForUpdates(region, hlaObject, attributes);
    }

    /// <summary>
    /// createRegions
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual internal bool createRegions()
    {
      try
      {
        foreach (var space in _som.RSList)
        {
          space.RtiAmb = _rtiAmb;
          // Set Dimensions
          foreach (var dimension in space.Dimensions)
          {
            dimension.Space = space;
            dimension.RtiAmb = _rtiAmb;
          }
          // Create Regions
          foreach (var region in space.Regions)
          {
            region.RtiAmb = _rtiAmb;
            region.CreateRegion(space);
          }
        }
        return true;
      }
      catch (Exception e)
      {
        MessageBox.Show("MSG-(RACoN.Federation.GenericFederate.createRegions):" + Environment.NewLine + e.ToString(), "RACoN", MessageBoxButtons.OK, MessageBoxIcon.Warning);
        return false;
      }
    }

    /// <summary>
    /// DeleteRegion
    /// </summary>
    virtual public bool DeleteRegion(CHlaRegion region)
    {
      if (_rtiAmb.deleteRegion(region)) return true;
      else return false;
    }

    /// <summary>
    /// Registers object with a specific region with all its publishable (P) attributes. Here, we assume that all attributes are related with a single region.
    /// </summary>
    /// <param name="theObject">Object to be registered. If object name is set then this method registers the object with its name. Object name must be unique.</param>
    /// <param name="region">The region. Here, we assume that all attributes are related with this region.</param>
    /// <returns>Returns true/false.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject, CHlaRegion region)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.// For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.Type.Handle); // returns null if not found
      bool res = false;
      //if (oc != null)
      res = RegisterHlaObject(theObject, theObject.Type.Attributes.ToList(), region);
      return res;
    }

    /// <summary>
    /// Registers object with a specific region with some of its publishable attributes. Here, we assume that all attributes are related with a single region.
    /// </summary>
    /// <param name="theObject">Object to be registered.</param>
    /// <param name="attributes">Selected object attributes that will be related with the region.</param>
    /// <param name="region">The region. Here, we assume that all attributes are related with this region.</param>
    /// <returns>Returns true/false.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject, List<HlaAttribute> attributes, CHlaRegion region)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      // Select only P or PS attributes
      List<HlaAttribute> pAttributes = new List<HlaAttribute>();
      List<CHlaRegion> regions = new List<CHlaRegion>();
      foreach (var attr in attributes)
      {
        if ((attr.AttributePS == PSKind.Publish) || (attr.AttributePS == PSKind.PublishSubscribe))
        {
          pAttributes.Add(attr);
          regions.Add(region);
        }
      }
      return _rtiAmb.registerObjectInstanceWithRegion(theObject, pAttributes, regions);
    }

    /// <summary>
    /// Registers object with its publishable attributes with specific regions. Each attribute may be associated with a different region. To do this, the user must pair an attribute with a region and then add the pair to a dictionary.
    /// </summary>
    /// <param name="theObject">Object to be registered.</param>
    /// <param name="attributeRegionPairs">Selected object attributes that will be related with the region.</param>
    /// <returns>Returns true/false.</returns>
    /// <example>
    /// This sample shows how to call the RegisterHlaObject(HlaObject theObject, AttributeRegionPairs attributeRegionPairs) method.
    /// <code>
    /// RACoN.ObjectModel.AttributeRegionPairs pairs = new RACoN.ObjectModel.AttributeRegionPairs();
    /// pairs.Add(myAttribute, myRegion);
    /// myFederate.RegisterHlaObject(myObject, pairs);
    /// </code>
    /// </example>
    virtual public bool RegisterHlaObject(HlaObject theObject, AttributeRegionPairs attributeRegionPairs)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // For IEEE1516.1_2010
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      Contract.Requires(theObject.Type.Handle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      // This is already ensured by Dictionary structure. Only unique keys are added to the dictionary
      //// Check that each attribute is listed only one time in the pairs.
      //var duplicates = attributeRegionPairs.GetPairs().Keys.GroupBy(x => x)
      //  .Where(x => x.Count() > 1).Select(x => x.Key).ToList();
      //if (duplicates.Count != 0) return false;

      // Select only P or PS attributes
      List<HlaAttribute> attributes = new List<HlaAttribute>();
      List<CHlaRegion> regions = new List<CHlaRegion>();
      foreach (var pair in attributeRegionPairs.GetPairs())
      {
        // Check that provided attribute is P or PS
        if ((pair.Key.AttributePS == PSKind.Publish) || (pair.Key.AttributePS == PSKind.PublishSubscribe))
        {
          // Get Attributes
          attributes.Add(pair.Key);
          // Get Regions
          regions.Add(pair.Value);
        }
      }
      return _rtiAmb.registerObjectInstanceWithRegion(theObject, attributes, regions);
    }

    /// <summary>
    /// Request Class Attribute Value Update w/ Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool RequestClassAttributeValueUpdateWithRegion(HlaObjectClass theClass, List<HlaAttribute> attributes, CHlaRegion region)
    {
      if (_rtiAmb.requestClassAttributeValueUpdateWithRegion(theClass, attributes, region)) return true;
      else return false;
    }

    /// <summary>
    /// // Subscribe Interaction With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SubscribeInteractionClass(HlaInteractionClass ic, CHlaRegion region)
    {
      _rtiAmb.subscribeInteractionClass(ic, region);
      return true;
    }

    /// <summary>
    /// // Subscribe Object Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool subscribeObjectClassAttributesWithRegion(HlaObjectClass oc, List<HlaAttribute> attributes, CHlaRegion region, bool active = true)
    {
      return _rtiAmb.subscribeObjectClassAttributesWithRegion(oc, attributes, region, active);
    }

    /// <summary>
    /// unassociateRegionForUpdates
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnassociateRegionForUpdates(CHlaRegion region, HlaObject hlaObject)
    {
      if (_rtiAmb.unassociateRegionForUpdates(region, hlaObject)) return true;
      else return false;
    }

    /// <summary>
    /// Unsubscribe Interaction Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeInteractionClass(HlaInteractionClass ic, CHlaRegion region)
    {
      _rtiAmb.unsubscribeInteractionClass(ic, region);
      return true;
    }

    /// <summary>
    /// Unsubscribe Object Class With Region
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UnsubscribeObjectClass(HlaObjectClass oc, CHlaRegion region)
    {
      _rtiAmb.unsubscribeObjectClassWithRegion(oc, region);
      return true;
    }

    #endregion

    #region Object Management
    /// <summary>
    /// Delete Object Instance
    /// </summary>
    virtual public bool DeleteObjectInstance(HlaObject obj)
    {
      if (_rtiAmb.deleteObjectInstance(obj)) return true;
      else return false;
    }

    /// <summary>
    /// Schedule to delete Object Instance at a specified time
    /// </summary>
    virtual public EventRetractionHandle DeleteObjectInstance(HlaObject obj, double time)
    {
      return _rtiAmb.deleteObjectInstance(obj, time);
    }

    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theClass">HLA Object Class</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method is called to request an update of the values of all attributes for all objects related to the specified HLA object class in the parameter.
    /// </remarks>
    virtual public bool RequestAttributeValueUpdate(HlaObjectClass theClass)
    {
      //List<HlaAttribute> attributes = new List<HlaAttribute>();
      //foreach (var attribute in theClass.Attributes)
      //{
      //  attributes.Add(attribute);
      //}
      if (_rtiAmb.requestAttributeValueUpdate(theClass, theClass.Attributes.ToList())) return true;
      else return false;
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theClass">HLA Object Class</param>
    /// <param name="attributes">The attribute set that update requested.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method is called to request an update of the values of the selected attributes for all objects related to the specified HLA object class in the parameter.
    /// </remarks>
    /// <example>
    /// This sample shows how to call the requestClassAttributeValueUpdate() method with some selected attributes.
    /// <code>
    /// List&lt;HlaAttribute&gt; attributes = new List&lt;HlaAttribute&gt;();
    /// attributes.Add(Som.UserOC.NickName);
    /// attributes.Add(Som.UserOC.Status);
    /// RequestAttributeValueUpdate(Som.UserOC, attributes);
    /// </code>
    /// </example>
    virtual public bool RequestAttributeValueUpdate(HlaObjectClass theClass, List<HlaAttribute> attributes)
    {
      if (_rtiAmb.requestAttributeValueUpdate(theClass, attributes)) return true;
      else return false;
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theObject">HLA Object</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method requests an update of the values of all attributes for a specific HLA object specified in the parameter.
    /// </remarks>
    virtual public bool RequestAttributeValueUpdate(HlaObject theObject)
    {
      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.ClassHandle); // returns null if not found
      bool res = false;
      //if (oc != null)
      try
      {
        res = RequestAttributeValueUpdate(theObject, theObject.Type.Attributes.ToList()); // if user forgets to set type of the object, then an exception generated
      }
      catch (Exception e)
      {
        logger.Add("When requesting attribute value, the object type for (" + theObject.Name + ") is not set. " + e.Message, LogLevel.WARN);
      }
      return res;
    }
    /// <summary>
    /// Request Attribute Value Update
    /// </summary>
    /// <param name="theObject">HLA Object</param>
    /// <param name="attributes">The attribute set that update requested.</param>
    /// <returns>True if method call is succesfull.</returns>
    /// <remarks>This method requests an update of the values of the selected attributes for a specific HLA object specified in the parameter.
    /// </remarks>
    /// <example>
    /// This sample shows how to call the requestClassAttributeValueUpdate() method with some selected attributes.
    /// <code>
    /// List&lt;HlaAttribute&gt; attributes = new List&lt;HlaAttribute&gt;();
    /// attributes.Add(Som.UserOC.NickName);
    /// attributes.Add(Som.UserOC.Status);
    /// RequestAttributeValueUpdate(UserObject, attributes);
    /// </code>
    /// </example>
    virtual public bool RequestAttributeValueUpdate(HlaObject theObject, List<HlaAttribute> attributes)
    {
      return (_rtiAmb.requestAttributeValueUpdate(theObject, attributes));
    }

    /// <summary>
    /// Sends an interaction. If a region is specified then send the interaction in that region.
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool SendInteraction(HlaInteraction theInteraction, CHlaRegion region = null)
    {
      bool res = false;

      if (region == null)
        res = _rtiAmb.sendInteraction(theInteraction);
      else
        res = _rtiAmb.sendInteraction(theInteraction, region);

      return res;
    }

    /// <summary>
    /// Send Interaction with timestamp.
    /// </summary>
    /// <param name="theInteraction">HLA interaction to be sent.</param>
    /// <param name="timestamp">timestamp.</param>
    /// <returns> returns Event Retraction Handle.</returns>
    virtual public EventRetractionHandle SendInteraction(HlaInteraction theInteraction, double timestamp)
    {
      return _rtiAmb.sendInteraction(theInteraction, timestamp);
    }

    /// <summary>
    /// Register (create) HLA Object.
    /// </summary>
    /// <param name="theObject">HLA Object to be registered.</param>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool RegisterHlaObject(HlaObject theObject)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      // This is ensured by the JOINED state
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at RegisterHlaObject().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at RegisterHlaObject().");
      //d) The object class is defined in the FDD
      //Contract.Requires(theObject.ClassHandle != 0, " at RegisterHlaObject()."); // Class handle will be 0 if not P/S.
      //e) The joined federate is publishing the object class.
      //Contract.Requires(theObject.Type.ClassPS == PSKind.PublishSubscribe || theObject.Type.ClassPS == PSKind.Publish, " at RegisterHlaObject().");
      //f) If the optional object instance name argument is supplied, that name is reserved and not already coadunated with another object instance.
      //g) Federate save not in progress.
      //h) Federate restore not in progress.

      // Postconditions
      //a) The returned object instance handle is coadunated with the object instance.
      Contract.Ensures(theObject.Handle != 0, " at RegisterHlaObject().");
      //b) The joined federate acquires ownership of the instance attributes that correspond to the currently published class attributes for the specified object class.
      //c) If the optional object instance name argument is supplied, that name is coadunated with the object instance.     
      #endregion

      bool result;
      if (theObject.Name != "")
        result = _rtiAmb.registerObject(theObject, theObject.Name);
      else
        result = _rtiAmb.registerObject(theObject);
      if (result) return true;
      else return false;
    }

    /// <summary>
    ///UpdateAttributeValues
    /// </summary>
    /// <returns>True if method call is succesfull.</returns>
    virtual public bool UpdateAttributeValues(HlaObject theObject)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at UpdateAttributeValues().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at UpdateAttributeValues().");
      //d) The joined federate owns the instance attributes for which values are provided.
      Contract.Requires(theObject.Handle != 0, " at UpdateAttributeValues().");
      //e) The attributes are defined in the FDD.
      //Contract.Requires(theObject.Type.Attributes.Count != 0, " at UpdateAttributeValues().");
      //f) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) The timestamp value shall be in accordance with the constraints stated in Clause 8 (if optional timestamp argument is supplied).
      //i) If the optional timestamp argument is supplied to this service invocation, the invoking joined federate is time-regulating, and it has invoked the Delete Object Instance service for the specified object instance with a timestamp argument (while time-regulating), then the update’s timestamp shall be less than or equal to the delete’s timestamp.
      //j) Federate save not in progress.
      //k) Federate restore not in progress.

      // Postconditions
      // a) The new instance attribute values have been supplied to the RTI.
      #endregion
      if (_rtiAmb.updateAttributeValues(theObject))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    ///UpdateAttributeValues with timestamp
    /// </summary>
    virtual public EventRetractionHandle UpdateAttributeValues(HlaObject theObject, Double timestamp)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at UpdateAttributeValues().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at UpdateAttributeValues().");
      //d) The joined federate owns the instance attributes for which values are provided.
      Contract.Requires(theObject.Handle != 0, " at UpdateAttributeValues().");
      //e) The attributes are defined in the FDD.
      //Contract.Requires(theObject.Type.Attributes.Count != 0, " at UpdateAttributeValues().");
      //f) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) The timestamp value shall be in accordance with the constraints stated in Clause 8 (if optional timestamp argument is supplied).
      //i) If the optional timestamp argument is supplied to this service invocation, the invoking joined federate is time-regulating, and it has invoked the Delete Object Instance service for the specified object instance with a timestamp argument (while time-regulating), then the update’s timestamp shall be less than or equal to the delete’s timestamp.
      //j) Federate save not in progress.
      //k) Federate restore not in progress.

      // Postconditions
      // a) The new instance attribute values have been supplied to the RTI.
      #endregion
      return _rtiAmb.updateAttributeValues(theObject, timestamp);
    }
    #endregion // Object Management

    #region Ownership Management

    /// <summary>
    /// Initiates an attempt to acquire a set of instanceattributes of an object instance. 
    /// Only instance-attributes that exist in the federation but are currently unowned will be acquired.
    /// </summary>
    virtual public bool AttributeOwnershipAcquisitionIfAvailable(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //e) The joined federate knows about the object instance with the specified designator.
      //i) Federate save not in progress.
      //j) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.attributeOwnershipAcquisitionIfAvailable(theObject, set))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Initiates an attempt to acquire a specified set of attributes of an object instance. 
    /// </summary>
    virtual public bool AttributeOwnershipAcquisition(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return _rtiAmb.attributeOwnershipAcquisition(theObject, set);
    }
    /// <summary>
    /// Initiates an attempt to acquire all attributes of an object instance. 
    /// </summary>
    virtual public bool AttributeOwnershipAcquisition(HlaObject theObject)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Create a set
      RaconAttributeSet set = new RaconAttributeSet();
      // Add all class attributes
      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.ClassHandle); // returns null if not found
      //if (oc != null)
      foreach (HlaAttribute attr in theObject.Type.Attributes)
        set.AddAttribute(attr);
      return AttributeOwnershipAcquisition(theObject, set);
    }

    /// <summary>
    /// Requests the cancellation of a previously requested ownership acquisition for a specified set of instance-attributes of a specified object instance.
    /// </summary>
    virtual public bool CancelAttributeOwnershipAcquisition(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.cancelAttributeOwnershipAcquisition(theObject, set))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Determines which federate (if any) holds the attribute ownership token for a given instance-attribute.
    /// </summary>
    virtual public bool QueryAttributeOwnership(HlaObject theObject, HlaAttribute attribute)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at QueryAttributeOwnership().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at QueryAttributeOwnership().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.queryAttributeOwnership(theObject, attribute))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Releases ownership of a set of instance-attributes for a specified instance, 
    /// in compliance with a requestAttribute-OwnershipRelease() request. HLA-13 specific?
    /// </summary>
    virtual public bool AttributeOwnershipReleaseResponse(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.attributeOwnershipReleaseResponse(theObject, set))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Cancels a previously requested negotiated ownership divestiture for a specified set of instance-attributes of a specified object instance.
    /// </summary>
    virtual public bool CancelNegotiatedAttributeOwnershipDivestiture(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.cancelNegotiatedAttributeOwnershipDivestiture(theObject, set))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Queries the LRC to determine whether a specified instance-attribute of a specified object instance is currently owned by the local federate.
    /// </summary>
    virtual public bool IsAttributeOwnedByFederate(HlaObject theObject, HlaAttribute attribute)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at attributeOwnershipReleaseResponse().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at attributeOwnershipReleaseResponse().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.isAttributeOwnedByFederate(theObject, attribute))
      {
        return true;
      }
      else return false;
    }

    /// <summary>
    /// Initiates an attempt to release ownership of a specified set of instance-attributes for a specified object instance. 
    /// In the absence of an acquiring federate, the instance-attributes will continue to be owned by the divesting federate.
    /// </summary>
    virtual public bool NegotiatedAttributeOwnershipDivestiture(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      return (_rtiAmb.negotiatedAttributeOwnershipDivestiture(theObject, set));
    }
    /// <summary>
    /// Initiates an attempt to release ownership of all instance-attributes for a specified object instance. 
    /// In the absence of an acquiring federate, the instance-attributes will continue to be owned by the divesting federate.
    /// </summary>
    virtual public bool NegotiatedAttributeOwnershipDivestiture(HlaObject theObject)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      // Create a set
      RaconAttributeSet set = new RaconAttributeSet();
      // Add all class attributes
      //HlaObjectClass oc = _som.OCList.SingleOrDefault(p => p.Handle == theObject.ClassHandle); // returns null if not found
      //if (oc != null)
      foreach (HlaAttribute attr in theObject.Type.Attributes)
        set.AddAttribute(attr);
      return NegotiatedAttributeOwnershipDivestiture(theObject, set);
    }

    /// <summary>
    /// Releases ownership of a specified set of instanceattributes for a specified object instance. The attributes immediately become unowned and are available for acquisition by any federate.
    /// </summary>
    virtual public bool UnconditionalAttributeOwnershipDivestiture(HlaObject theObject, RaconAttributeSet set)
    {
      #region Contracts
      // Preconditions
      //a) The federate is connected to the RTI.
      //b) The federation execution exists.
      Contract.Requires(FederationExecutionState == FederationExecutionStates.FEDEX_EXISTS, " at AttributeOwnershipAcquisitionIfAvailable().");
      //c) The federate is joined to that federation execution.
      Contract.Requires(FederateState.HasFlag(FederateStates.JOINED), " at AttributeOwnershipAcquisitionIfAvailable().");
      //d) An object instance with the specified designator exists.
      //g) The joined federate knows about the object instance with the specified designator.
      //h) Federate save not in progress.
      //i) Federate restore not in progress.

      // Postconditions
      #endregion

      if (_rtiAmb.unconditionalAttributeOwnershipDivestiture(theObject, set))
      {
        return true;
      }
      else return false;
    }

    #endregion // Ownership Management

    #region Time Management
    /// <summary>
    /// Enable Async Delivery - HLA13
    /// </summary>
    virtual public bool EnableAsyncDelivery()
    {
      if (_rtiAmb.enableAsynchronousDelivery()) return true;
      else return false;
    }

    /// <summary>
    /// ChangeAttributeOrderType
    /// </summary>
    virtual public bool ChangeAttributeOrderType(HlaObject theObject, List<HlaAttribute> attributes, OrderType type)
    {
      if (_rtiAmb.changeAttributeOrderType(theObject, attributes, (uint)type)) return true;
      else return false;
    }

    /// <summary>
    /// ChangeInteractionOrderType
    /// </summary>
    virtual public bool ChangeInteractionOrderType(HlaInteractionClass ic, OrderType type)
    {
      if (_rtiAmb.changeInteractionOrderType(ic, (uint)type)) return true;
      else return false;
    }


    /// <summary>
    /// Disable Async Delivery - HLA13
    /// </summary>
    virtual public bool DisableAsyncDelivery()
    {
      if (_rtiAmb.disableAsynchronousDelivery()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Time Constrained - HLA13
    /// </summary>
    virtual public bool DisableTimeConstrained()
    {
      if (_rtiAmb.disableTimeConstrained()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Time Regulation - HLA13
    /// </summary>
    virtual public bool DisableTimeRegulation()
    {
      if (_rtiAmb.disableTimeRegulation()) return true;
      else return false;
    }

    /// <summary>
    /// Enable Time Constrained - HLA13
    /// </summary>
    virtual public bool EnableTimeConstrained()
    {
      if (_rtiAmb.enableTimeConstrained()) return true;
      else return false;
    }

    /// <summary>
    /// Enable Time Regulation - HLA13. parameters are seconds
    /// </summary>
    virtual public bool EnableTimeRegulation(Double federateTime, Double lookahead)
    {
      if (_rtiAmb.enableTimeRegulation(federateTime, lookahead)) return true;
      else return false;
    }

    /// <summary>
    /// FlushQueueRequest
    /// </summary>
    virtual public bool FlushQueueRequest(Double time)
    {
      if (_rtiAmb.flushQueueRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// NextEventRequest
    /// </summary>
    virtual public bool NextEventRequest(Double time)
    {
      if (_rtiAmb.nextEventRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// NextEventRequestAvailable
    /// </summary>
    virtual public bool NextEventRequestAvailable(Double time)
    {
      if (_rtiAmb.nextEventRequestAvailable(time)) return true;
      else return false;
    }

    /// <summary>
    /// ModifyLookahead
    /// </summary>
    virtual public bool ModifyLookahead(Double time)
    {
      if (_rtiAmb.modifyLookahead(time)) return true;
      else return false;
    }

    /// <summary>
    /// QueryFederateTime
    /// </summary>
    virtual public Double QueryFederateTime()
    {
      return _rtiAmb.queryFederateTime();
    }

    /// <summary>
    /// QueryLBTS
    /// </summary>
    virtual public Double QueryLBTS()
    {
      return _rtiAmb.queryLBTS();
    }

    /// <summary>
    /// Query
    /// </summary>
    virtual public Double QueryLookahead()
    {
      return _rtiAmb.queryLookahead();
    }

    /// <summary>
    /// Query
    /// </summary>
    virtual public Double QueryMinNextEventTime()
    {
      return _rtiAmb.queryMinNextEventTime();
    }

    /// <summary>
    /// Retract
    /// </summary>
    virtual public bool Retract(EventRetractionHandle retraction)
    {
      if (_rtiAmb.retract(retraction)) return true;
      else return false;
    }

    /// <summary>
    /// TimeAdvanceRequest
    /// </summary>
    virtual public bool TimeAdvanceRequest(Double time)
    {
      if (_rtiAmb.timeAdvanceRequest(time)) return true;
      else return false;
    }

    /// <summary>
    /// TimeAdvanceRequest Available
    /// </summary>
    virtual public bool TimeAdvanceRequestAvailable(Double time)
    {
      if (_rtiAmb.timeAdvanceRequestAvailable(time)) return true;
      else return false;
    }

    #endregion // Time Management

    #region Supporting Services
    /// <summary>
    /// Enable Attribute Relevance Advisory Switch enables the generation of the Attribute Relevance Advisory Switch service advisory 
    /// </summary>
    virtual public bool EnableAttributeRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableAttributeRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// EnableAttributeScopeAdvisorySwitch
    /// </summary>
    virtual public bool EnableAttributeScopeAdvisorySwitch()
    {
      if (_rtiAmb.enableAttributeScopeAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// EnableInteractionRelevanceAdvisorySwitch
    /// </summary>
    virtual public bool EnableInteractionRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableInteractionRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Enable Object Class Relevance Advisory Switch enables the generation of the Start/Stop Registration For Object Class service advisory 
    /// <paramref name="FdAmb_StartRegistrationForObjectClassAdvisedHandler"></paramref>
    /// </summary>
    virtual public bool EnableObjectClassRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.enableObjectClassRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Attribute Relevance Advisory Switch disables the generation of the Attribute Relevance Advisory Switch service advisory
    /// </summary>
    virtual public bool DisableAttributeRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableAttributeRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// DisableAttributeScopeAdvisorySwitch
    /// </summary>
    virtual public bool DisableAttributeScopeAdvisorySwitch()
    {
      if (_rtiAmb.disableAttributeScopeAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Disable Object Class Relevance Advisory Switch disables the generation of the Start/Stop Registration For Object Class service advisory <paramref name="FdAmb_StartRegistrationForObjectClassAdvisedHandler"/>
    /// </summary>
    virtual public bool DisableObjectClassRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableObjectClassRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// DisableInteractionRelevanceAdvisorySwitch
    /// </summary>
    virtual public bool DisableInteractionRelevanceAdvisorySwitch()
    {
      if (_rtiAmb.disableInteractionRelevanceAdvisorySwitch()) return true;
      else return false;
    }

    /// <summary>
    /// Evoke Callback
    /// <param name="approximateMinimumTimeInSeconds">this service invocation shall wait for the duration indicated by this argument. Default is 0.01 sec (1 msec)</param>
    /// </summary>
    virtual public void EvokeCallback(double approximateMinimumTimeInSeconds = 0.01)
    {
      _rtiAmb.evokeCallback(approximateMinimumTimeInSeconds);
    }

    /// <summary>
    /// Instructs the RTI that the invoking federate is prepared to receive multiple federate callbacks.The service shall continue to process available callbacks until the minimum specified wall-clock time. At that wall-clock time, if there are no additional callbacks to be delivered to the federate, the service shall complete. If, after the minimum specified wall-clock time, there continue to be callbacks, the RTI shall continue to deliver those callbacks until the maximum specified wall-clock time is exceeded.
    /// <param name="approximateMinimumTimeInSeconds">Min amount of wallclock time. </param>
    /// <param name="approximateMaximumTimeInSeconds">Max amount of wallclock time.</param>
    /// </summary>
    virtual public void EvokeMultipleCallbacks(double approximateMinimumTimeInSeconds, double approximateMaximumTimeInSeconds)
    {
      _rtiAmb.evokeMultipleCallbacks(approximateMinimumTimeInSeconds, approximateMaximumTimeInSeconds);
    }
    /// <summary>
    /// Tick() is alias for Evoke Callback
    /// </summary>
    virtual public void Tick()
    {
      EvokeCallback();
    }

    /// <summary>
    /// Tick(min, max) is alias for Evoke Multiple Callbacks
    /// <param name="minimum">the minimum time interval (in wall clock seconds) to spend in tick()</param>
    /// <param name="maximum">the maximum time interval (in wall clock seconds) after which tick() will not begin execution of any additional processing</param>
    /// </summary>
    virtual public void Tick(double minimum, double maximum)
    {
      EvokeMultipleCallbacks(minimum, maximum);
    }
    #endregion // Supporting Services

    #endregion // RtiAmb Function Wrappers

    #endregion // Methods
  }
}
